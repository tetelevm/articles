# Ещё одна статья про алгоритмы оптимизации


## Жадный алгоритм

Определение из википедии: алгоритм, заключающийся в принятии локально оптимальных
решений на каждом этапе, допуская, что конечное решение также окажется
оптимальным.

В целом, все эвристические алгоритмы делятся на "жадные" и "нежадные".
Жадный алгоритм в любой из итераций обязательно улучает итоговый
результат и перестаёт быть жадным, если в какой-то своей части он делает
"нежадный" (не самый локально выгодный) шаг.
Исполняется алгоритм до тех пор, пока есть пространство для оптимизации и пока
он может исполняться (то есть пока алгоритм не зайдёт в минимум).

По сути, это не один конкретный алгоритм, а некое абстрактное представление
класса алгоритмов, запрограммированных на решение задач в цикле.
Жадный алгоритм используется не для _оптимизации_ найденного решения, а для
_нахождения_ первого локального минимума конкретной задачи.
Алгоритм исполняется всегда по единому пути при одинаковых входных данных и
сходится на первом минимуме, который ему встретится.

Как один из примеров можно взять [алгоритм K-средних][k_means].
Для начала инициализируются начальные данные - точки для кластеризации и
количество и положение центров кластеров.
Затем при каждой итерации подсчитывается для каждой из точек вычисляется
ближайший центр кластера, после чего в зависимости от помеченных точек центры
приводятся в более выгодные положения.
Каждая из этих операций выбирает наиболее выгодное решение, не ухудшая решение
ни на каком из этапов.

Другие примеры жадных алгоритмов: алгоритм Хаффмана (наиболее жадно кодирует 
биты в сообщении), градиентный спуск (каждую итерацию выбирает наиболее выгодное
направление и длину шага), симплекс-метод (на каждом шаге выбирает наиболее
выгодное ребро многоугольника).

Проблема алгоритма в его неоптимальности: так как алгоритм исполняется только на
улучшение результата без каких-то дополнительных поисков, то в сложной функции
он скорее всего не найдёт глобальный (или близкий к нему) минимум.
В связи с этим алгоритм используют либо в тех случаях, когда функция имеет только
один минимум (алгоритм Хаффмана, симплекс-метод, алгоритм Дейкстры), либо когда
функция не сильно зашумлена и любой из локальных минимумов эффективен (метод
K-средних, градиентный спуск, алгоритм Краскала).

Плюсы алгоритма:
- самый быстрый из алгоритмов: так как работает только на нахождение решения без
    оптимизации, то и работает быстрее других
- наиболее простая точка остановки: если алгоритм зашёл в минимум - останавливаем
- базовый алгоритм для остальных (не плюс, но особенность): на жадном алгоритме
    реализуются алгоритмы оптимизации, которые каким-то образом модифицируют его

Минусы:
- малая область применимости: поскольку алгоритм прямолинейный, то чистым может
    применяться только в определённых довольно простых случаях.
    В то же время алгоритмы оптимизации сложных задач основываются на жадном
    алгоритме.

## Алгоритм имитации отжига

Один из первых алгоритмов, пришёл в наш мир ещё в 1983 году.
Физическая основа - плавное застывание материала, когда жидкое вещество начинает
кристаллизоваться и устаканиваться в лучшей позиции.
Название алгоритм получил в честь процесса отжига металлов - это как раз и есть
нагревание и плавное охлаждение металла, при котором атомы формируют
кристаллическую решётку.
Во время охлаждения атомы связываются друг с другом, что и создаёт клетки
решётки.
Но всегда имеется небольшой шанс, что атом перейдёт из одной клетки в другую.
Этот шанс зависит от температуры материала - чем она выше, тем ниже порог для
перехода, и тем шанс перехода больше.

На этом и основан алгоритм.
Для начала устанавливается некоторая абстрактная величина - температура, и с
каждой итерацией температура уменьшается.
От температуры зависит, какой шанс у объекта совершить переход из одного
состояния в другое.

Как это понимать: если у нас есть вариант решения с итоговым значением  `110`
(требуется уменьшить итоговое значение), а текущий вариант имеет размер `100`,
то жадный алгоритм бы сразу отсёк новое решение.
Но имитация отжига - не жадный алгоритм, и поэтому есть шанс, что он примет
новое решение, хоть оно и хуже изначального.

Такое решение даёт возможность не сидеть в локальном минимуме (что и делает
жадный алгоритм), а иметь шанс выйти из него.
Но чтобы итоговое решение всё же имело не потенциал для решения, а само решение,
температура и уменьшается, и в конце алгоритм будет напоминать просто жадный.

Плюсы алгоритма:
- очень прост для внедрения в задачу: так как вся особенность его работы
    заключается в простом выборе `да/нет`, то для реализации при существующем
    жадном алгоритме достаточно просто заменить выбор решения с 
    `if (current_solution > new_solution) { current_solution = new_solution }`
    на `if make_decision(current_solution, new_solution) { current_solution = new_solution }`
- прост для реализации: в функции `make_decision`, по большому счёту, будет
    просто лежать формула `random(0, 1) < e**(delta / temperature)`
- предельно понятная точка остановки: температура упала - пора выключать

Минусы алгоритма:
- мало работы для напильника: в качестве настроек есть только скорость остывания
- не самые лучшие результаты: часто зависает в локальном минимуме


## Генетический алгоритм

Генетический алгоритм появлялся долго и давно, ещё в 60-70 годах, и как ни
странно, он вдохновлён естественным отбором из реального мира.

Суть его заключается в простой идее - если случайным образом мутировать
параметры и оставлять только лучшие из мутаций, то в итоге можно прийти к
локальному минимуму.

Для реализации алгоритма нужно сначала скопировать первоначальное решение или
создать популяцию из случайных решений, и в дальнейшем работать с ними.
Затем мутировать полученную популяцию.
Мутация, что очень удобно, может браться из жадного алгоритма, что позволяет
легко надстроить генетический алгоритм над жадным.
После мутации нужно отобрать лучшие особи и создать новую популяцию - просто
скопировав лучшие или скрещивая их между собой (что не всегда возможно).
И через некоторое количество повторений алгоритм найдёт оптимальное решение.

Проблема алгоритма в том, что он застревает в минимумах.

Плюсы:
- быстро работает: каждую итерацию стабильно оптимизирует нужную функцию
- легко встраивается и реализовывается: если есть жадный алгоритм, то пара
    небольших функций реализует и генетический алгоритм

Минусы:
- плохо ищет глобальным минимум: алгоритм хорошо скатывается в какую-то одну
    сторону, но плохо поднимается наверх.
    Зато легко исправляется комбинацией с алгоритмом, который хорошо ищет общую
    структуру, но плохо локальные оптимумы, например, с муравьиным.


## Алгоритм муравьиной колонии.

Придумали [муравьиный алгоритм][ant_colony] в 1992 году, активно начал
использоваться с начала нулевых.
Придумали после наблюдения за муравьями и термитами, что логично вытекает из
названия.
Муравьи двигаются не просто так по земле, а оставляют во время своих похождений
феромоновый след - пахнущее (для муравьёв) вещество, тёмной полоской выделяющееся
среди асфальта на путях муравьиных троп.
И коллективно умные муравьи при поиске еды ходят не туда, куда глядят фасеточные
глаза, а туда, куда ведёт вкусный феромоновый след.

Из этого и наследуется суть алгоритма: есть некоторое количество независимых
юнитов (муравьёв), которые двигаются сами по себе, и есть общая локация, по
которой двигаются юниты.
Локация содержит точки, через которые и проходят юниты, а также карту феромонов.
Феромоны представляют собой просто абстрактные числа, от которых зависит,
по какому пути пойдёт юнит в будущем.

Каждую итерацию алгоритма колония отправляется в путь по локации.
При прохождении пути (расположения/поворота/..., в зависимости от задачи)
каждый из юнитов с некоторой вероятностью выбирает следующую точку.
Вероятность для каждой точки зависит от силы феромонов, лежащих на каждом
возможном пути.
То есть, если нужно сделать выбор из 5 точек, феромоны для которых
`[9, 0, 0, 3, 0]`, то с вероятностью 75% он выберет нулевую, а с вероятностью
25% третью.
Остальные же вообще не будут выбраны, так как к ним не ведут феромоновые дороги.
После того как точка выбрана, юнит перемещается к ней и выбирает заново из
оставшихся.

После каждого выпуска юнитов все феромоны на локации немного уменьшаются, а по
пройденным путям добавляются новые, причём на более оптимальные пути их
добавляется больше.
Оптимизационная идея заключается в том, что чем короче путь, тем больше на него
будет установлено новых феромонов, тем больше вероятность, что в следующий раз
по нему пройдёт больше юнитов и оставит свои феромоны, и таким образом этот
более оптимальный путь всплывёт наверх.

Как можно заметить, суть работы этого алгоритма отличается от предыдущих - он
не изменяет некое начальное значение, а набирает свою собственную статистику
результатов и ориентируется на неё.
Поэтому не получится просто взять готовый жадный алгоритм, накинуть поверх него
логики и получить муравьиный.

Зато, в отличие от прошлых алгоритмов, он не сильно зависит от прошлых 
результатов, что позволяет исправлять локальные ямы. 
Пример для коммивояжёра: в пути `[0, 1, 5, 4, 3, 2, 6, 7]` перекрещиваются
линии `1-5` и `2-6`, остальные стоят правильно.
Более оптимальное решение требует переставить эти две точки местами, но тогда
необходимо развернуть участок `5-4-3-2`.
Иначе, если не развернуть, то проблема останется - будут перекрещиваться не
`1-5` с `2-6`, а `2-4` с `3-5`, и проблема не решится.
Муравьиный же алгоритм независим от текущего решения, он каждый раз строит его
заново, и вполне может перестанавливать линии куда ему вздумается, если это будет
выгодно.

![Проблема перекрещивания путей][image_crossing_lines]

Самих муравьиных алгоритмов есть много разных, и между собой они могут сильно
отличаться, но суть у всех в том, что юниты не взаимодействуют друг с другом,
а общаются через среду (карту феромонов).
Из-за этой абстракции алгоритм легко модифицируется.
Например, можно добавить особых муравьёв-разведчиков, которые ходят независимо
от существующих феромонов, элитных муравьёв, которые ходят только по самым
коротким путям.
Можно играть с установкой феромонов - сделать минимальный порог для феромонов,
устанавливать только лучшим путям, ввести для особых муравьёв изменённое
количество феромонов.
В целом алгоритм хороший для тех случаев, когда суть задачи заключается как раз
в оптимизации чего-то, а не в создании универсального решения.

Плюсы:
- хорошо оптимизирует общую структуру пути: достаточно быстро вырисовывается
    решение, которое довольно оптимальное в глобальном плане, и в дальнейшем
    решение остаётся глобально неплохим
- хорошая оптимизация: если правильно настроить и дать достаточно времени на
    вычисления, то результат будет очень хорошим
- большое пространство для изменения: муравьиный алгоритм довольно сложный и
    абстрактный и можно сильно изменять его структуру
- много параметров для настройки: даже без изменения алгоритма можно изменять
    количество муравьёв, коэффициент испарения, коэффициент новых феромонов
- простое понимание точки остановки: когда ясно, что феромоны кристаллизовались,
    тогда и выключать
- отлично параллелится: основная вычсложность - прохождение муравьями пути, и
    это очень легко вычислять независимо друг от друга

Минусы:
- сложная реализация: тут и карта феромонов, и табу-поиск, и юниты-акторы,
    гораздо сложнее генетического алгоритма и, тем более, отжига
- сложно встроить: если у вас уже есть жадный алгоритм оптимизации, то это не
    значит, что вам будет просто внедрить муравьиный.
    Муравьиному алгоритму нужно знать, что за функция изменения, происходит на
    локации, как сделан выбор решения
- требуется пачка напильников: ещё одна обратная сторона сложности, просто так
    алгоритм не заработает.
    Перед этим нужно будет много и долго оптимизировать его параметры (поставим
    алгоритм оптимизации в алгоритм оптимизации, чтобы ты мог оптимизировать
    алгоритм оптимизации пока оптимизируешь задачу)
- плохо оптимизирует локальные недочёты: если две точки расположены рядом, то
    первой может выбрать более дальнюю, а затем вернуться ко второй.
    Происходит оттого, что соседние точки оказывают малое влияние на общий
    результат, и вначале локальная неоптимальность может просто не играть роли,
    а в конце феромоны по такому пути уже слишком сильны.
    Чинится либо модификациями алгоритма (порог, разведчики), либо просто пустить
    по полученному решению жадный/генетический алгоритм.
- сложно увидеть промежуточные результаты: оптимизация происходит сильно
    нелинейно, и без анализа карты феромонов сложно понять, насколько данный
    путь оптимален и насколько он ещё может измениться



[k_means]: https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_k-%D1%81%D1%80%D0%B5%D0%B4%D0%BD%D0%B8%D1%85
[ant_colony]: https://en.wikipedia.org/wiki/Ant_colony_optimization_algorithms

[image_crossing_lines]: /russian/алгоритмы_оптимизации/imgs/crossing_lines.png "Проблема пересе"












