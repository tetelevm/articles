
## Жадный алгоритм





## Алгоритм имитации отжига

Один из первых алгоритмов, пришёл в наш мир ещё в 1983 году.
Физическая основа алгоритма - плавное застывание материала.
Название алгоритм получил в честь процесса отжига металлов - это как раз и есть
нагревание и плавное охлаждение металла, при котором атомы формируют
кристаллическую решётку.
Во время охлаждения атомы связываются друг с другом, что и создаёт клетки
решётки.
Но всегда имеется небольшой шанс, что атом перейдёт из одной клетки в другую.
Этот шанс зависит от температуры материала - чем она выше, тем ниже порог для
перехода, и тем шанс перехода больше.

На этом и основан алгоритм.
Для начала устанавливается некоторая абстрактная величина - температура, и с
каждой итерацией температура уменьшается.
От температуры зависит, какой шанс у объекта совершить переход из одного
состояния в другое.

Как это понимать: если у нас есть вариант решения с итоговым значением  `110`
(требуется уменьшить итоговое значение), а текущий вариант имеет размер `100`,
то жадный алгоритм бы сразу отсёк новое решение.
Но имитация отжига - не жадный алгоритм, и поэтому есть шанс, что он примет
новое решение, хоть оно и хуже изначального.

Такое решение даёт возможность не сидеть в локальном минимуме (что и делает
жадный алгоритм), а иметь шанс выйти из него.
Но чтобы итоговое решение всё же имело не потенциал для решения, а само решение,
температура и уменьшается, и в конце алгоритм будет напоминать просто жадный.

Плюсы алгоритма:
- очень прост для внедрения в задачу: так как вся особенность его работы
    заключается в простом выборе `да/нет`, то для реализации при существующем
    жадном алгоритме достаточно просто заменить выбор решения с 
    `if (current_solution > new_solution) { current_solution = new_solution }`
    на `if make_decision(current_solution, new_solution) { current_solution = new_solution }`
- прост для реализации: в функции `make_decision`, по большому счёту, будет
    просто лежать формула `random(0, 1) < e**(delta / temperature)`
- предельно понятная точка остановки: температура упала - пора выключать

Минусы алгоритма:
- мало работы для напильника: в качестве настроек есть только скорость остывания
- не самые лучшие результаты: часто зависает в локальном минимуме


## Генетический алгоритм

Генетический алгоритм появлялся долго и давно, ещё в 60-70 годах, и как ни
странно, он вдохновлён естественным отбором из реального мира.

Суть его заключается в простой идее - если случайным образом мутировать
параметры и оставлять только лучшие из мутаций, то в итоге можно прийти к
локальному минимуму.

Для реализации алгоритма нужно сначала скопировать первоначальное решение или
создать популяцию из случайных решений, и в дальнейшем работать с ними.
Затем мутировать полученную популяцию.
Мутация, что очень удобно, может браться из жадного алгоритма, что позволяет
легко надстроить генетический алгоритм над жадным.
После мутации нужно отобрать лучшие особи и создать новую популяцию - просто
скопировав лучшие или скрещивая их между собой (что не всегда возможно).
И через некоторое количество повторений алгоритм найдёт оптимальное решение.

Проблема алгоритма в том, что он застревает в минимумах.

Плюсы:
- быстро работает: каждую итерацию стабильно оптимизирует нужную функцию
- легко встраивается и реализовывается: если есть жадный алгоритм, то пара
    небольших функций реализует и генетический алгоритм

Минусы:
- плохо ищет глобальным минимум: алгоритм хорошо скатывается в какую-то одну
    сторону, но плохо поднимается наверх.
    Зато легко исправляется комбинацией с алгоритмом, который хорошо ищет общую
    структуру, но плохо локальные оптимумы, например, с муравьиным.




## Алгоритм муравьиной колонии.

> вики: https://en.wikipedia.org/wiki/Ant_colony_optimization_algorithms

Придумали алгоритм в 1992 году, активно начал использоваться с начала нулевых.
Придумали после наблюдения за муравьями и термитами, что логично вытекает из
названия.
Муравьи двигаются не просто так по земле, а оставляют во время своих похождений
феромоновый след - пахнущее (для муравьёв) вещество, тёмной полоской выделяющееся
среди асфальта на путях муравьиных троп.
И коллективно умные муравьи при поиске еды ходят не туда, куда глядят фасеточные
глаза, а туда, куда ведёт вкусный феромоновый след.

Из этого и наследуется суть алгоритма: есть некоторое количество независимых
юнитов (муравьёв), которые двигаются сами по себе, и есть общая локация, по
которой двигаются юниты.
Локация содержит точки, через которые и проходят юниты, а также карту феромонов.
Феромоны представляют собой просто абстрактные числа, от которых зависит,
по какому пути пойдёт юнит в будущем.

Каждую итерацию алгоритма колония отправляется в путь по локации.
При прохождении пути (расположения/поворота/..., в зависимости от задачи)
каждый из юнитов с некоторой вероятностью выбирает следующую точку.
Вероятность для каждой точки зависит от силы феромонов, лежащих на каждом
возможном пути.
То есть, если нужно сделать выбор из 5 точек, феромоны для которых
`[9, 0, 0, 3, 0]`, то с вероятностью 75% он выберет нулевую, а с вероятностью
25% третью.
Остальные же вообще не будут выбраны, так как к ним не ведут феромоновые дороги.
После того как точка выбрана, юнит перемещается к ней и выбирает заново из
оставшихся.

После каждого выпуска юнитов все феромоны на локации немного уменьшаются, а по
пройденным путям добавляются новые, причём на более оптимальные пути их
добавляется больше.
Оптимизационная идея заключается в том, что чем короче путь, тем больше на него
будет установлено новых феромонов, тем больше вероятность, что в следующий раз
по нему пройдёт больше юнитов и оставит свои феромоны, и таким образом этот
более оптимальный путь всплывёт наверх.

Как можно заметить, суть работы этого алгоритма отличается от предыдущих - он
не изменяет некое начальое значение, а набирает свою собственную статистику
результатов и ориентируется на неё.
Поэтому не получится просто взять готовый жадный алгоритм, накинуть поверх него
логики и получить муравьиный.

Зато, в отличие от прошлых алгоритмов, он не сильно зависит от прошлых 
результатов, что позволяет исправлять локальные ямы. 
Пример для коммивояжёра: в пути `[0, 1, 6, 5, 4, 3, 2, 7, 8]` перекрещиваются
линии `1-6` и `2-7`, остальные стоят правильно.
Более правильное решение требует переставить эти две точки местами, но тогда
необходимо развернуть участок `6-5-4-3-2`.
Иначе, если не развернуть, то проблема останется - будут перекрещиваться не
`1-6` с `2-7`, а `2-5` с `3-6`, и проблема не решится.
Муравьиный же алгоримт независим от текущего решения, он каждый раз строит его
заново, и вполне может перестанавливть линии куда ему вздумается, если это будет
выгодно.

Самих муравьиных алгоритмов есть много разных, и между собой они могут сильно
отличаться, но суть у всех в том, что юниты не взаимодействуют друг с другом,
а общаются через среду (карту феромонов).
Из-за этой абстракции алгоритм легко модифицируется.
Например, можно добавить особых муравьёв-разведчиков, которые ходят независимо
от существующих феромонов, элитных муравьёв, которые ходят только по самым
коротким путям.
Можно играть с установкой феромонов - сделать минимальный порог для феромонов,
устанавливать только лучшим путям, ввести для особых муравьёв изменённое
количество феромонов.
В целом алгоритм хороший для тех случаев, когда суть задачи заключается как раз
в оптимизации чего-то, а не в создании универсального решения.

Плюсы:
- хорошо оптимизирует общую структуру пути: достаточно быстро вырисовывается
    решение, которое довольно оптимальное в глобальном плане, и в дальнейшем
    решение остаётся глобально неплохим
- хорошая оптимизация: если правильно настроить и дать достаточно времени на
    вычисления, то результат будет очень хорошим
- большое пространство для изменения: муравьиный алгоритм довольно сложный и
    абстрактный и можно сильно изменять его структуру
- много параметров для настройки: даже без изменения алгоритма можно изменять
    количество муравьёв, коэффициент испарения, коэффициент новых феромонов
- простое понимание точки остановки: когда ясно, что феромоны кристаллизовались,
    тогда и выключать
- отлично параллелится: основная вычсложность - прохождение муравьями пути, и
    это очень легко вычислять независимо друг от друга

Минусы:
- сложная реализация: тут и карта феромонов, и табу-поиск, и юниты-акторы,
    гораздо сложнее генетического алгоритма и, тем более, отжига
- сложно встроить: если у вас уже есть жадный алгоритм оптимизации, то это не
    значит, что вам будет просто внедрить муравьиный.
    Муравьиному алгоритму нужно знать, что за функция изменения, происходит на
    локации, как сделан выбор решения
- требуется пачка напильников: ещё одна обратная сторона сложности, просто так
    алгоритм не заработает.
    Перед этим нужно будет много и долго оптимизировать его параметры (поставим
    алгоритм оптимизации в алгоритм оптимизации, чтобы ты мог оптимизировать
    алгоритм оптимизации пока оптимизируешь задачу)
- плохо оптимизирует локальные недочёты: если две точки расположены рядом, то
    первой может выбрать более дальнюю, а затем вернуться ко второй.
    Происходит оттого, что соседние точки оказывают малое влияние на общий
    результат, и вначале локальная неоптимальность может просто не играть роли,
    а в конце феромоны по такому пути уже слишком сильны.
    Чинится либо модификациями алгоритма (порог, разведчики), либо просто пустить
    по полученному решению жадный/генетический алгоритм.
- сложно увидеть промежуточные результаты: оптимизация происходит сильно
    нелинейно, и без анализа карты феромонов сложно понять, насколько данный
    путь оптимален и насколько он ещё может измениться

P.S. Довольно интересный алгоритм, нужно будет сделать по нему отдельный проект
и статью.


















